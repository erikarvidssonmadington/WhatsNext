{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const cpx = require(\"cpx\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst fsExtra = require(\"fs-extra\");\nconst rimraf = require(\"rimraf\");\nconst mv = require(\"mv\");\nconst makeDir = require(\"make-dir\");\nconst archiver = require(\"archiver\");\n\nclass FileManagerPlugin {\n  constructor(options) {\n    this.options = this.setOptions(options);\n    this.isWin = /^win/.test(process.platform);\n\n    /* cpx options */\n    this.cpxOptions = {\n      clean: false,\n      includeEmptyDirs: true,\n      update: false,\n    };\n  }\n\n  setOptions(userOptions) {\n    const defaultOptions = {\n      verbose: false,\n      moveWithMkdirp: false,\n      onStart: {},\n      onEnd: {},\n    };\n\n    for (const key in defaultOptions) {\n      if (userOptions.hasOwnProperty(key)) {\n        defaultOptions[key] = userOptions[key];\n      }\n    }\n\n    return defaultOptions;\n  }\n\n  checkOptions(stage) {\n    if (this.options.verbose && Object.keys(this.options[stage]).length) {\n      console.log(`FileManagerPlugin: processing ${stage} event`);\n    }\n\n    let operationList = [];\n\n    if (this.options[stage] && Array.isArray(this.options[stage])) {\n      this.options[stage].map(opts => operationList.push(...this.parseFileOptions(opts, true)));\n    } else {\n      operationList.push(...this.parseFileOptions(this.options[stage]));\n    }\n\n    if (operationList.length) {\n      operationList.reduce((previous, fn) => {\n        return previous.then(retVal => fn(retVal)).catch(err => console.log(err));\n      }, Promise.resolve());\n    }\n  }\n\n  copyDirectory(source, destination, resolve, reject) {\n    if (this.options.verbose) {\n      console.log(`  - FileManagerPlugin: Start copy source file: ${source} to destination file: ${destination}`);\n    }\n\n    cpx.copy(source, destination, this.cpxOptions, err => {\n      if (err && this.options.verbose) {\n        console.log(\"  - FileManagerPlugin: Error - copy failed\", err);\n        reject(err);\n      }\n\n      if (this.options.verbose) {\n        console.log(`  - FileManagerPlugin: Finished copy source: ${source} to destination: ${destination}`);\n      }\n\n      resolve();\n    });\n  }\n\n  replaceHash(filename) {\n    return filename.replace(\"[hash]\", this.fileHash);\n  }\n\n  parseFileOptions(options, preserveOrder = false) {\n    const optKeys = Object.keys(options);\n\n    let commandOrder = [];\n\n    for (let i = 0; i < optKeys.length; i++) {\n      const fileAction = optKeys[i];\n      const fileOptions = options[fileAction];\n\n      switch (fileAction) {\n        case \"copy\":\n          for (let key in fileOptions) {\n            const command = {\n              source: this.replaceHash(fileOptions[key].source),\n              destination: this.replaceHash(fileOptions[key].destination),\n            };\n\n            if (!command.source || !command.destination) {\n              if (this.options.verbose) {\n                console.log(\n                  \"  - FileManagerPlugin: Warning - copy parameter has to be formated as follows: { source: <string>, destination: <string> }\",\n                );\n              }\n              return;\n            }\n\n            commandOrder.push(\n              () =>\n                new Promise((resolve, reject) => {\n                  // if source is a file, just copyFile()\n                  // if source is a NOT a glob pattern, simply append **/*\n                  const fileRegex = /(\\*|\\{+|\\}+)/g;\n                  const matches = fileRegex.exec(command.source);\n\n                  if (matches === null) {\n                    fs.lstat(command.source, (sErr, sStats) => {\n                      if (sErr) return reject(sErr);\n\n                      fs.lstat(command.destination, (dErr, dStats) => {\n                        if (sStats.isFile()) {\n                          const destination =\n                            dStats && dStats.isDirectory()\n                              ? command.destination + \"/\" + path.basename(command.source)\n                              : command.destination;\n\n                          if (this.options.verbose) {\n                            console.log(\n                              `  - FileManagerPlugin: Start copy source: ${\n                                command.source\n                              } to destination: ${destination}`,\n                            );\n                          }\n\n                          /*\n                           * If the supplied destination is a directory copy inside.\n                           * If the supplied destination is a directory that does not exist yet create it & copy inside\n                           */\n\n                          const pathInfo = path.parse(destination);\n\n                          const execCopy = (src, dest) => {\n                            fsExtra.copy(src, dest, err => {\n                              if (err) reject(err);\n                              resolve();\n                            });\n                          };\n\n                          if (pathInfo.ext === \"\") {\n                            makeDir(destination).then(mPath => {\n                              execCopy(command.source, destination + \"/\" + path.basename(command.source));\n                            });\n                          } else {\n                            execCopy(command.source, destination);\n                          }\n                        } else {\n                          const sourceDir = command.source + (command.source.substr(-1) !== \"/\" ? \"/\" : \"\") + \"**/*\";\n                          this.copyDirectory(sourceDir, command.destination, resolve, reject);\n                        }\n                      });\n                    });\n                  } else {\n                    this.copyDirectory(command.source, command.destination, resolve, reject);\n                  }\n                }),\n            );\n          }\n\n          break;\n\n        case \"move\":\n          for (let key in fileOptions) {\n            const command = {\n              source: this.replaceHash(fileOptions[key].source),\n              destination: this.replaceHash(fileOptions[key].destination),\n            };\n\n            if (!command.source || !command.destination) {\n              if (this.options.verbose) {\n                console.log(\n                  \"  - FileManagerPlugin: Warning - move parameter has to be formated as follows: { source: <string>, destination: <string> }\",\n                );\n              }\n              return;\n            }\n\n            if (fs.existsSync(command.source)) {\n              commandOrder.push(\n                () =>\n                  new Promise((resolve, reject) => {\n                    if (this.options.verbose) {\n                      console.log(\n                        `  - FileManagerPlugin: Start move source: ${command.source} to destination: ${\n                          command.destination\n                        }`,\n                      );\n                    }\n\n                    mv(command.source, command.destination, { mkdirp: this.options.moveWithMkdirp }, err => {\n                      if (err) {\n                        if (this.options.verbose) {\n                          console.log(\"  - FileManagerPlugin: Error - move failed\", err);\n                        }\n                        reject(err);\n                      }\n\n                      if (this.options.verbose) {\n                        console.log(\n                          `  - FileManagerPlugin: Finished move source: ${command.source} to destination: ${\n                            command.destination\n                          }`,\n                        );\n                      }\n\n                      resolve();\n                    });\n                  }),\n              );\n            } else {\n              process.emitWarning(\"  - FileManagerPlugin: Could not move \" + command.source + \": path does not exist\");\n            }\n          }\n\n          break;\n\n        case \"delete\":\n          if (!Array.isArray(fileOptions)) {\n            throw Error(\n              `  - FileManagerPlugin: Fail - delete parameters has to be type of 'strings array' but was '${typeof fileOptions}'. Process canceled.`,\n            );\n          }\n\n          for (let key in fileOptions) {\n            const path = this.replaceHash(fileOptions[key]);\n\n            commandOrder.push(\n              () =>\n                new Promise((resolve, reject) => {\n                  if (this.options.verbose) {\n                    console.log(`  - FileManagerPlugin: Starting delete path ${path}`);\n                  }\n\n                  if (typeof path !== \"string\") {\n                    if (this.options.verbose) {\n                      console.log(\n                        \"  - FileManagerPlugin: Warning - delete parameter has to be type of string. Process canceled.\",\n                      );\n                    }\n                    reject();\n                  }\n\n                  rimraf(path, {}, response => {\n                    if (this.options.verbose && response === null) {\n                      console.log(`  - FileManagerPlugin: Finished delete path ${path}`);\n                    }\n                    resolve();\n                  });\n                }),\n            );\n          }\n\n          break;\n\n        case \"mkdir\":\n          for (let key in fileOptions) {\n            const path = this.replaceHash(fileOptions[key]);\n\n            if (this.options.verbose) {\n              console.log(`  - FileManagerPlugin: Creating path ${path}`);\n            }\n\n            if (typeof path !== \"string\") {\n              if (this.options.verbose) {\n                console.log(\n                  \"  - FileManagerPlugin: Warning - mkdir parameter has to be type of string. Process canceled.\",\n                );\n              }\n              return;\n            }\n\n            commandOrder.push(() => makeDir(path));\n          }\n\n          break;\n\n        case \"archive\":\n          for (let key in fileOptions) {\n            const command = {\n              source: this.replaceHash(fileOptions[key].source),\n              destination: fileOptions[key].destination,\n              format: fileOptions[key].format ? fileOptions[key].format : \"zip\",\n              options: fileOptions[key].options ? fileOptions[key].options : { zlib: { level: 9 } },\n            };\n\n            if (!command.source || !command.destination) {\n              if (this.options.verbose) {\n                console.log(\n                  \"  - FileManagerPlugin: Warning - archive parameter has to be formated as follows: { source: <string>, destination: <string> }\",\n                );\n              }\n              return;\n            }\n\n            commandOrder.push(\n              () =>\n                new Promise((resolve, reject) => {\n                  const fileRegex = /(\\*|\\{+|\\}+)/g;\n                  const matches = fileRegex.exec(command.source);\n\n                  const isGlob = matches !== null ? true : false;\n\n                  fs.lstat(command.source, (sErr, sStats) => {\n                    const output = fs.createWriteStream(command.destination);\n                    const archive = archiver(command.format, command.options);\n\n                    archive.on(\"error\", err => {\n                      reject(err);\n                    });\n\n                    archive.pipe(output);\n\n                    if (isGlob) archive.glob(command.source, command.options.globOptions || {});\n                    else if (sStats.isFile()) archive.file(command.source, { name: path.basename(command.source) });\n                    else if (sStats.isDirectory()) archive.directory(command.source, false);\n\n                    archive.finalize().then(() => resolve());\n                  });\n                }),\n            );\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return commandOrder;\n  }\n\n  apply(compiler) {\n    const that = this;\n\n    const comp = compilation => {\n      try {\n        that.checkOptions(\"onStart\");\n      } catch (error) {\n        compilation.errors.push(error);\n      }\n    };\n\n    const afterEmit = (compilation, cb) => {\n      that.fileHash = compilation.hash;\n\n      try {\n        that.checkOptions(\"onEnd\");\n      } catch (error) {\n        compilation.errors.push(error);\n      }\n\n      cb();\n    };\n\n    if (compiler.hooks) {\n      compiler.hooks.compilation.tap(\"compilation\", comp);\n      compiler.hooks.afterEmit.tapAsync(\"afterEmit\", afterEmit);\n    } else {\n      compiler.plugin(\"compilation\", comp);\n      compiler.plugin(\"after-emit\", afterEmit);\n    }\n  }\n}\n\nexport default FileManagerPlugin;\n"],"names":["cpx","require","fs","path","fsExtra","rimraf","mv","makeDir","archiver","FileManagerPlugin","options","setOptions","isWin","test","process","platform","cpxOptions","userOptions","defaultOptions","key","hasOwnProperty","stage","verbose","Object","keys","length","log","operationList","Array","isArray","map","push","parseFileOptions","opts","reduce","previous","fn","then","retVal","catch","console","err","Promise","resolve","source","destination","reject","copy","filename","replace","fileHash","optKeys","commandOrder","i","fileAction","fileOptions","command","replaceHash","fileRegex","matches","exec","lstat","sErr","sStats","dErr","dStats","isFile","isDirectory","basename","pathInfo","parse","execCopy","src","dest","ext","sourceDir","substr","copyDirectory","existsSync","mkdirp","moveWithMkdirp","emitWarning","Error","response","format","zlib","level","isGlob","output","createWriteStream","archive","on","pipe","glob","globOptions","file","name","directory","finalize","compiler","that","comp","checkOptions","error","errors","afterEmit","compilation","cb","hash","hooks","tap","tapAsync","plugin"],"mappings":"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"}